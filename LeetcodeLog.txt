2018年07月12日22:48:15:
	1 Two Sum
2018年07月12日22:47:31:  
	27 Remove Element, 11 Container With Most Water [M], 35 Search Insert Position
	66 Plus One, 119 Pascal's Triangle II
2018年07月13日13:17:51
	26 Remove Duplicates from Sorted Array，167 Two Sum II - Input array is sorted, 189 Rotate Array, 118 Pascal's Triangle, 88 Merge Sorted Array, 121 Best Time to Buy and Sell Stock

	* 167 和 11 都用了 “逼近法”的思想，即首尾部设置隔板逐渐逼近，可以在o(n)时间完成
	* 26和27都用了two-pointer的思想，设置一个pointer检查是否满足条件，而另一个pointer则是用来保存/更新数值
	* 26要take notice, 去掉重复项可以使用sort!
	* 189 用reverse, reverse, reverse法来做，可以做到原地
	* 121 折线图法，数值下降=更新最小值minprice，数值上升=（可能）更新最大利润maxprofit
2018年07月14日11:50:19
	53 Maximum Subarray, 122 Best Time to Buy and Sell Stock II, 
	169 Majority Element, 219 Contains Duplicate II, 217 Contains Duplicate
	268 Missing Number

	* 53: Kadane Algorithm: divide and conquor
	语法：(maxCurrentSum > 0 ? maxCurrentSum : 0)
	* 219: 用hashmap就可以，有一个good idea: map.put(key, value)可以返回之前的previous value
	* 268: 1. XOR异或运算 2. 用(long)0-n求和-所有数，再转换为int得到最后数，防止overflow
2018年07月15日12:26:12
	283 Move Zeroes, 326 Power of Three, 15 3Sum, 18 4Sum

	* 283 本来很简单的一道题，就是在array中用后面的值覆盖前面的值，想得太复杂了，和27的Remove Element是同一个方法。
	* 326 while-loop，或者找到integer.MAX_VALUE最近的那个3的幂，直接除
	* 15 Three Sum 主要思想是1.先排序，2.采用LC167的sorted two-sum的思想 3.考虑重复项
	* 18 Four Sum 主要思路根据3-sum 1.排序 2.筛检重复项 3.ThreeSum
	其中注意很多时候可以省去工作量，比如nums[i]开始4个连续数是否已经大于target/threetarget
	关于为什么要筛选重复项，因为到第一个数的时候，后面凡是含有这个数（比如1）的所有组合已经遍历了，因此后续已经没有必要继续考虑该数，因此可直接跳过。而后面的3-sum也是一样。

2018年07月16日15:54:12
	438 Find All Anagrams in a String, 406 Queue Reconstruction by Height
	316 Remove Duplicate Letters

	* 438: method: 
		1. HashMap.getOrDefault(key, 0) + 1
		2. String.toCharArray()
		3. Sliding Window的思想
	* 406: 先按一定规则排序，后swap,关于Comparator的使用：
		Arrays.sort(people, new Comparator<int[]>() {
            public int compare(int[] a, int[] b) {
                return xxx;
            }   });
    * 316: Stack; arrays that can count the appearing times; 
    then we can check the times when they appear again, to make ensure whether the number is still remained or satisfied. *字符串计数器 *Stack的应用

2018年07月17日12:51:31:
    141. Linked List Cycle, 142. Linked List Cycle II, 16. 3Sum Closest
    31. Next Permutation 33. Search in Rotated Sorted Array

    * 141: 判断linked list是否存在cycle: 用两个指针，一个速度为1的slow和一个速度为2的fast，当他们重合的时候即说明存在circle.
    * 142: 判断起点在哪里, 当slow和fast重合时，从起点出发速度为1，从slow出发速度为1，当两者重合时即为出发点。
    * 16: 主要思想还是排序+把3sum分割成2sum,随后根据2sum和twotarget的差找到最合适的值并返回。
    * 31: 还是要多考虑一下原因，找出合适的规律然后写程序
    * 33: 分情况讨论, 比如Pivot在左边还是右边，同样的如果落在左边，那么右边则是递增数列，target如果落在右边的话就好处理了，如果落在左边就移动high，进入下一个循环（divide and conquor)；同理，如果pivot落在哟变，那么左边递增，target如果落在左边很好处理，*注意范围！，如果落在右边的话就继续进入下一循环。

2018年07月18日10:28:09:
	2. Add Two Numbers, 3. Longest Substring Without Repeating Characters, 43. Multiply Strings, 134. Gas Station, 387. First Unique Character in a String

	* 2: 主要考察了Linkedlist的知识，要注意起点和终点，是否等于null 或者next等于null的情况。
	* 3: Sliding Window, 要注意边缘情况，同时应该在no duplicate的时候更新，这样可以减少代码量
	* 43: 字符串乘法，可以分解成每个char的乘法，然后用数组保存起来，之后再进行进位运算等操作。
	* 134: 采用了差数列求和大于0的思想+求得最大整数和片段
	用了kadane算法但作了一点修改，比如头尾相接（复制数组放到后面）以及从后往前确定start point等。
	* 134: char[26]保存各个字母的次数，然后再次遍历string s来看首次出现1的，如果全程未出现就返回-1，非常简单

2018年07月19日09:42:57:
	219. Contains Duplicate II [2], 102. Binary Tree Level Order Traversal,
	93. Restore IP Addresses, 34. Find First and Last Position of Element in Sorted Array, 39. Combination Sum

	* 102的主要思想: 
	1. 用DFS遍历
	2. √ 用另一个变量height来控制层数，使得相应的node加入相应的list
	3. √ 用tree.get(height)来调用之前已经存过的list，这是之前没有想到的。一直不知道怎么调用之前已经创建的list，
	其实原来还可以用这个方法！
	* 93主要是遍历，找到所有的可能性,整体思路还是比较简单的。复杂度应该是3*3*3*3,constant?
	* 34就是用简单的二分法，找到第一个满足的就用[mid,mid]保存，之后因为是连续的只要不断更新上下限的值就可以了。
	* 39: backtracking questions, 明日再看. 今天的主要思想就是先排序，然后递归，从整除的开始算起。

2018年07月20日13:53:14:
	54. Spiral Matrix, 289. Game of Life, 240. Search a 2D Matrix II
	48. Rotate Image, 55. Jump Game, 56. Merge Intervals

	* 289: 
	1. 九种情况的另一种表达方法
	for (int x = Math.max(i - 1, 0); x <= Math.min(i + 1, m - 1); x++) {
        for (int y = Math.max(j - 1, 0); y <= Math.min(j + 1, n - 1); y++) {
        }
    }
    2. 多采用位运算，比如，对于1、0等不能更改的值，可以吧1表示为i&1
    3. 移位运算符: >> signed right shift operator. 比如 10 >> 1 = 1, 11 >> 1 = 1, 01 >> 1 = 0...
    题中， 最后是向右移位取得更新值，而在计算board的时候是取最右的一位
    即： 一共两位，左边更新值，右边初值，所以： 最初： 00 -> 0, 01 -> 1
    1 -> 0: 不需要做任何改动; 1 -> 1: 01 -> 11; 0 -> 1: 00 -> 2; 0 -> 0: 不需要任何改动
    基于以上，在更新计算ones时: ones += i & 1;   在记录更新board值时: 根据以上规律即可
    最后将board值更新: i >>= 1;
    4. 复习计算机位运算储存方法

    * 240: 
    1. Integers in each row are sorted in ascending from left to right.
    2. Integers in each column are sorted in ascending from top to bottom.
    This is called Young Tableau. Just start from the right upper corner. If the target is larger, then just go down. Else if the target is smaller, then just go left. Since every element on the lower right is larger, and every element on the upper left is smaller, you just need to go DOWN or go LEFT. And the time complexity is O(m + n).
    * 48: 四个四个轮换, 注意矩阵下标转换时相对坐标和绝对坐标的关系
    * 55: backward的思想
    * 56: 注意interval.end要取一个max来保存, 其他就是用了sort和一些corner case

2018年07月21日10:52:44:
	49. Group Anagrams, 456. 132 Pattern, 209. Minimum Size Subarray Sum
	38. Count and Say, 58. Length of Last Word

	* 49: 用Map<String, List>存储结构
		1. 对于anagrams，可以用char[], 可以用Map<Character, Integer>，也可以分成char[]后排序检查string是否一致
		2. 关于Collection, Collections的用法 
		3. 尽量避免重复代码, 关于Map新建ArrayList并赋值, 可以先Map.put(key, new ArrayList<>())再Map.get(key).add(value)l
	* 456: 比较难的优化问题，留到以后解决，目前最佳用的是O(n2)的算法
	* 209: 整体思路很简单，还是two-point + slidng window的思想。目标是要求找到sum >= s的最短长度，那么可以设置start和end，用two-point的方法。设置end为：从start开始，每次到end的和sum都是刚好>=s的。然后跳出循环，在start的循环中，设定条件while(sum >= s)，每次更新length的长度，并且增加一个start直到sum < s为止。这样不断的后移end,后移start，就可以得到值啦！
	* 38: 简单的递归

2018年07月22日13:22:42:
	136. Single Number, 260. Single Number III, 210. Course Schedule II

	* 136: 位运算！位运算！位运算！用XOR来做
	* 260: XOR + 二进制正负 位运算！
	* 210: 终极graph + dfs + topological

2018年07月23日16:19:20:
	445. Add Two Numbers II, 454. 4Sum II

	* 445: 用stack来存储linkedlist里面的数并进行运算，主要是因为要把它颠倒过来，共用3个stack。
	注意加法容易遗漏的点：即所有位数已经加完但是进位还不为0的情况，这时候要把进位加上去。
	* 454: 考虑到即使值相同，index也有可能不同，那么就把4-sum问题转换为2-sum。即，对于A和B中的每个元素进行相加，得到n^2个组合，同理，将C和D中的每个元素相加，得到n^2个组合。那么再看AB中的值是否对应CD中的值，这样可以遍历所有可能的情况。
	但是AB的值可以存储在数组中，也可以不存储，而CD的值则存储在HashMap中，其中第二个参数为值出现的个数，这是因为要考虑到不同的组合的缘故。最后在O(n^2)的time complexity和space中就可以进行求解。
	







