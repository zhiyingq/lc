2018年07月12日22:48:15:
	1 Two Sum
2018年07月12日22:47:31:  
	27 Remove Element, 11 Container With Most Water [M], 35 Search Insert Position
	66 Plus One, 119 Pascal's Triangle II
2018年07月13日13:17:51
	26 Remove Duplicates from Sorted Array，167 Two Sum II - Input array is sorted, 189 Rotate Array, 118 Pascal's Triangle, 88 Merge Sorted Array, 121 Best Time to Buy and Sell Stock

	* 167 和 11 都用了 “逼近法”的思想，即首尾部设置隔板逐渐逼近，可以在o(n)时间完成
	* 26和27都用了two-pointer的思想，设置一个pointer检查是否满足条件，而另一个pointer则是用来保存/更新数值
	* 26要take notice, 去掉重复项可以使用sort!
	* 189 用reverse, reverse, reverse法来做，可以做到原地
	* 121 折线图法，数值下降=更新最小值minprice，数值上升=（可能）更新最大利润maxprofit
2018年07月14日11:50:19
	53 Maximum Subarray, 122 Best Time to Buy and Sell Stock II, 
	169 Majority Element, 219 Contains Duplicate II, 217 Contains Duplicate
	268 Missing Number

	* 53: Kadane Algorithm: divide and conquor
	语法：(maxCurrentSum > 0 ? maxCurrentSum : 0)
	* 219: 用hashmap就可以，有一个good idea: map.put(key, value)可以返回之前的previous value
	* 268: 1. XOR异或运算 2. 用(long)0-n求和-所有数，再转换为int得到最后数，防止overflow
2018年07月15日12:26:12
	283 Move Zeroes, 326 Power of Three, 15 3Sum, 18 4Sum

	* 283 本来很简单的一道题，就是在array中用后面的值覆盖前面的值，想得太复杂了，和27的Remove Element是同一个方法。
	* 326 while-loop，或者找到integer.MAX_VALUE最近的那个3的幂，直接除
	* 15 Three Sum 主要思想是1.先排序，2.采用LC167的sorted two-sum的思想 3.考虑重复项
	* 18 Four Sum 主要思路根据3-sum 1.排序 2.筛检重复项 3.ThreeSum
	其中注意很多时候可以省去工作量，比如nums[i]开始4个连续数是否已经大于target/threetarget
	关于为什么要筛选重复项，因为到第一个数的时候，后面凡是含有这个数（比如1）的所有组合已经遍历了，因此后续已经没有必要继续考虑该数，因此可直接跳过。而后面的3-sum也是一样。

2018年07月16日15:54:12
	438 Find All Anagrams in a String, 406 Queue Reconstruction by Height
	316 Remove Duplicate Letters

	* 438: method: 
		1. HashMap.getOrDefault(key, 0) + 1
		2. String.toCharArray()
		3. Sliding Window的思想
	* 406: 先按一定规则排序，后swap,关于Comparator的使用：
		Arrays.sort(people, new Comparator<int[]>() {
            public int compare(int[] a, int[] b) {
                return xxx;
            }   });
    * 316: Stack; arrays that can count the appearing times; 
    then we can check the times when they appear again, to make ensure whether the number is still remained or satisfied. *字符串计数器 *Stack的应用

2018年07月17日12:51:31:
    141. Linked List Cycle, 142. Linked List Cycle II, 16. 3Sum Closest
    31. Next Permutation 33. Search in Rotated Sorted Array

    * 141: 判断linked list是否存在cycle: 用两个指针，一个速度为1的slow和一个速度为2的fast，当他们重合的时候即说明存在circle.
    * 142: 判断起点在哪里, 当slow和fast重合时，从起点出发速度为1，从slow出发速度为1，当两者重合时即为出发点。
    * 16: 主要思想还是排序+把3sum分割成2sum,随后根据2sum和twotarget的差找到最合适的值并返回。
    * 31: 还是要多考虑一下原因，找出合适的规律然后写程序
    * 33: 分情况讨论, 比如Pivot在左边还是右边，同样的如果落在左边，那么右边则是递增数列，target如果落在右边的话就好处理了，如果落在左边就移动high，进入下一个循环（divide and conquor)；同理，如果pivot落在哟变，那么左边递增，target如果落在左边很好处理，*注意范围！，如果落在右边的话就继续进入下一循环。

2018年07月18日10:28:09:
	2. Add Two Numbers, 3. Longest Substring Without Repeating Characters, 43. Multiply Strings, 134. Gas Station, 387. First Unique Character in a String

	* 2: 主要考察了Linkedlist的知识，要注意起点和终点，是否等于null 或者next等于null的情况。
	* 3: Sliding Window, 要注意边缘情况，同时应该在no duplicate的时候更新，这样可以减少代码量
	* 43: 字符串乘法，可以分解成每个char的乘法，然后用数组保存起来，之后再进行进位运算等操作。
	* 134: 采用了差数列求和大于0的思想+求得最大整数和片段
	用了kadane算法但作了一点修改，比如头尾相接（复制数组放到后面）以及从后往前确定start point等。
	* 134: char[26]保存各个字母的次数，然后再次遍历string s来看首次出现1的，如果全程未出现就返回-1，非常简单

2018年07月19日09:42:57:
	219. Contains Duplicate II [2], 102. Binary Tree Level Order Traversal,
	93. Restore IP Addresses, 34. Find First and Last Position of Element in Sorted Array, 39. Combination Sum

	* 102的主要思想: 
	1. 用DFS遍历
	2. √ 用另一个变量height来控制层数，使得相应的node加入相应的list
	3. √ 用tree.get(height)来调用之前已经存过的list，这是之前没有想到的。一直不知道怎么调用之前已经创建的list，
	其实原来还可以用这个方法！
	* 93主要是遍历，找到所有的可能性,整体思路还是比较简单的。复杂度应该是3*3*3*3,constant?
	* 34就是用简单的二分法，找到第一个满足的就用[mid,mid]保存，之后因为是连续的只要不断更新上下限的值就可以了。
	* 39: backtracking questions, 明日再看. 今天的主要思想就是先排序，然后递归，从整除的开始算起。

	









