2018年07月12日22:48:15:
	1 Two Sum
2018年07月12日22:47:31:  
	27 Remove Element, 11 Container With Most Water [M], 35 Search Insert Position
	66 Plus One, 119 Pascal's Triangle II
2018年07月13日13:17:51
	26 Remove Duplicates from Sorted Array，167 Two Sum II - Input array is sorted, 189 Rotate Array, 118 Pascal's Triangle, 88 Merge Sorted Array, 121 Best Time to Buy and Sell Stock

	* 167 和 11 都用了 “逼近法”的思想，即首尾部设置隔板逐渐逼近，可以在o(n)时间完成
	* 26和27都用了two-pointer的思想，设置一个pointer检查是否满足条件，而另一个pointer则是用来保存/更新数值
	* 26要take notice, 去掉重复项可以使用sort!
	* 189 用reverse, reverse, reverse法来做，可以做到原地
	* 121 折线图法，数值下降=更新最小值minprice，数值上升=（可能）更新最大利润maxprofit
2018年07月14日11:50:19
	53 Maximum Subarray, 122 Best Time to Buy and Sell Stock II, 
	169 Majority Element, 219 Contains Duplicate II, 217 Contains Duplicate
	268 Missing Number

	* 53: Kadane Algorithm: divide and conquor
	语法：(maxCurrentSum > 0 ? maxCurrentSum : 0)
	* 219: 用hashmap就可以，有一个good idea: map.put(key, value)可以返回之前的previous value
	* 268: 1. XOR异或运算 2. 用(long)0-n求和-所有数，再转换为int得到最后数，防止overflow
2018年07月15日12:26:12
	283 Move Zeroes, 326 Power of Three, 15 3Sum, 18 4Sum

	* 283 本来很简单的一道题，就是在array中用后面的值覆盖前面的值，想得太复杂了，和27的Remove Element是同一个方法。
	* 326 while-loop，或者找到integer.MAX_VALUE最近的那个3的幂，直接除
	* 15 Three Sum 主要思想是1.先排序，2.采用LC167的sorted two-sum的思想 3.考虑重复项
	* 18 Four Sum 主要思路根据3-sum 1.排序 2.筛检重复项 3.ThreeSum
	其中注意很多时候可以省去工作量，比如nums[i]开始4个连续数是否已经大于target/threetarget
	关于为什么要筛选重复项，因为到第一个数的时候，后面凡是含有这个数（比如1）的所有组合已经遍历了，因此后续已经没有必要继续考虑该数，因此可直接跳过。而后面的3-sum也是一样。

2018年07月16日15:54:12
	438 Find All Anagrams in a String, 406 Queue Reconstruction by Height
	316 Remove Duplicate Letters

	* 438: method: 
		1. HashMap.getOrDefault(key, 0) + 1
		2. String.toCharArray()
		3. Sliding Window的思想
	* 406: 先按一定规则排序，后swap,关于Comparator的使用：
		Arrays.sort(people, new Comparator<int[]>() {
            public int compare(int[] a, int[] b) {
                return xxx;
            }   });
    * 316: Stack; arrays that can count the appearing times; 
    then we can check the times when they appear again, to make ensure whether the number is still remained or satisfied. *字符串计数器 *Stack的应用

2018年07月17日12:51:31:
    141. Linked List Cycle, 142. Linked List Cycle II, 16. 3Sum Closest
    31. Next Permutation 33. Search in Rotated Sorted Array

    * 141: 判断linked list是否存在cycle: 用两个指针，一个速度为1的slow和一个速度为2的fast，当他们重合的时候即说明存在circle.
    * 142: 判断起点在哪里, 当slow和fast重合时，从起点出发速度为1，从slow出发速度为1，当两者重合时即为出发点。
    * 16: 主要思想还是排序+把3sum分割成2sum,随后根据2sum和twotarget的差找到最合适的值并返回。
    * 31: 还是要多考虑一下原因，找出合适的规律然后写程序
    * 33: 分情况讨论, 比如Pivot在左边还是右边，同样的如果落在左边，那么右边则是递增数列，target如果落在右边的话就好处理了，如果落在左边就移动high，进入下一个循环（divide and conquor)；同理，如果pivot落在哟变，那么左边递增，target如果落在左边很好处理，*注意范围！，如果落在右边的话就继续进入下一循环。












