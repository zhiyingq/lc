2018年10月01日09:53:31:
	179. Largest Number, 200. Number of Islands, 199. Binary Tree Right Side View, 198. House Robber

	* 179: 主要是comparator的使用，有一个很简单的方法比较两个string的先后顺序，就是直接看a+b和b+a的大小。*(一开始没想到)。然后考虑一个corner case,就是有leading 0的情况，有leading 0说明0是最大的，那么显然后面所有的数都是0，在这时候只要直接返回0就可以了。

	* 200: 比较简单的dfs，只要计算进行了多少次dfs就可以了。把visit过的改成'*'，这样就不需要使用额外的space，然后再把它改回来。

	* 199: Do BFS, 每一层只要取queue中最后一个元素即可。
	* 198: rob OR not rob, 如果rob，那么之前肯定是notrob，再加上现在的值就好了。
	如果not rob,那么可能之前是rob了，也有可能之前没有rob，我们只要取这两个数中的最大值就可以了。

	或者另一个思路，首先考虑每一个house, 偷完这个house后只能偷house + 2或者house + 3的房子，没道理直接去house + 4的，这是因为完全可以去house + 2再去house + 4。那么同样的，每一个house都来源于之前的House - 2或者house - 3, 我们只要取其中的最大值再加上nums[i]就可以了。但是这样的话我们就要比较并返回最后两个点中的较大值。-  -

2018年10月02日08:45:55:
	201. Bitwise AND of Numbers Range, 202. Happy Number

	* 201: Math.floor(log2(m)) should be equal to Math.floor(log2(n)). Otherwise the reuslt will definitely be 0. Then the highest digit must be 1. And we substract the power of 2 from m and n and do recursive calculations.

	* 202: 有点类似除法运算，保存每一个digit square sum，一旦出现重复的就说明这个数不行，跳出循环返回false，而一旦出现1就返回true。