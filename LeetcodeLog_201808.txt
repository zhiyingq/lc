2018年08月01日15:18:54:
	274. H-Index

	* 274: According to the definition of h-index on Wikipedia: "A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have no more than h citations each."
	H-index: 正好有x个大于x的数。首先思路想到是排序，然后从后往前倒，直到出现第一个citations[i] <= i的情况，就可以返回。但是排序的时间是O(nlgn)。
	第二种方法，使用count sorting, 即生成0，1，2，...,n的一个数组，每一个位存放大于等于这个index又小于index+1的数的个数，那么最后一位就是大于等于而没有上限。然后逆序往回，通常来说，等>=index的个数 >= index了，就说明我们的h有一个下限是index。对于index而言，肯定至少有Index个数>=它，这是利用了count的特性，即index对应的数只能是Index（除了最后一个),而其他的数都小于等于它，此时返回即可。由于是count sorting，时间是O(n).

2018年08月02日16:29:20:
	567. Permutation in String

	** Sliding Window主要思想: 
	array[end]: 简易记法，字符串s.charAt(end)所对应的那个letter出现的次数，保存在array中

	设置一个end和一个begin, 一个数组记录letter出现的个数，count记录不同letter的种类。
	每次array[end]--， 如果array[end]为0，count--， 而如果count为0，返回true。
	当然array[end]有可能为负，那么当其为负数的时候，则开始向右移动begin，每次移动array[begin]++，直到array[end]变正为止，当然过程中涉及到count的变化————要注意当array[begin]从0变成1的时候，说明某个数又被添加回队列，
	所以标志性的就是array[begin]++后，判断array[begin] == 1，从而看一下是否要改变count。

2018年08月03日23:54:19:
	204 Count Primes

	* 204: Sieve of Eratosthenes, 先设定一个长度为n的数组，从2开始，把2的倍数全部去掉，再从3开始，把3的倍数全部去掉……以此类推，同时每看到一个素数就count一下，返回所有的值。

2018年08月04日12:24:33:
	19. Remove Nth Node From End of List, 61. Rotate List, 83. Remove Duplicates from Sorted List, 82. Remove Duplicates from Sorted List II, 86. Partition List


	* 19: linkedlist的典型例题
	1. dummy的使用，有效地避免了只有一个head并且需要删除head的问题
	2. two-pointer的灵活使用，slow & fast
	3. deleteFromEnd可以先让fast走n步，然后再一起走，这样fast到尾部的时候slow总是比fast慢n步。这样就可以定位要所要删除的位置

	* 61: 比较简单，没啥好说的，先确定长度，在确定需要旋转的index，最后再考虑一点corner case
	* 82: 比较类似的思想,和83是同类题
	* 86: 用了两种方法，第一种，定位length以及tail，把所有大数按个移到最后。
	第二种方法是One-pass的，即直接用两个dummy,一个连接大数一个连接小数，最后首尾相接。在计算过程中考虑必要的corner case以及代码运行的机制。

2018年08月06日08:51:52: 
	21. Merge Two Sorted Lists, 24. Swap Nodes in Pairs, 92. Reverse Linked List II, 143. Reorder List, 147. Insertion Sort List

	* 21: dummy + traverse OR recursion
	* 92: 有一点动态规划的意思，本来做的是找到需要reverse的片段的首尾，然后再逐个添加。但其实不用的，只要不断把“尾巴”往后添加一个就可以了，这样就不需要先找到tail了。如果"tail"和"head"相差的比较大，那么这个算法就是2n的时间。而优化的算法用One-pass就可以通过了。
	* 143: 找到mid， reverse后半部分， 逐个插入
	* 157: 稍微有点搞脑子，需要一个dummy来保持list头，同时也要非常小心list尾部next需要剪除，否则很容易导致死循环。在这题里，dummy不需要首先和head相连，反而是直接新建一个dummy把剩下的一个个放上去即可。
	







