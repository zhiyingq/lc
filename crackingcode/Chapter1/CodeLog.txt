2018年08月02日16:56:04:
	1.1 isUniqe
	1） set法 ✔
	2) 128位ASCII码数组法 (未想到)
	3) lowercase位运算法	(未想到)
	ASCII和set的思路很好理解
	关于使用位运算，因为字符串都是由lowercase组成的，a-z即0-25，是小于32位的，因此，1可以表示成Ox0001,一旦出现一个字符，比如'c'，我们可以把'c'-'a'保存起来，作为1左移的距离。在这里就是左移两位，同时我们有一个计数器为counter，初始值为0，这样当前26个bit中某一个和左移后的1进行与运算大于0的时候，就知道是重复了。

	1.2 Check Permutation
	1) ASCII: 建立对应的char[128]数组，存放并判断是否相等
	可以采用“减去法”，即先完成一个数组，然后从里面减去相应的元素判断是否为0，这样可以大大节省时间和空间复杂度
	2) HashMap法+减去法：适用于所有Unicode字符
	3) 排序+判断两个数组是否相等
	排序是非常有用的算法，但是时间复杂度比较高。Arrays.equals(a, b)

	1.3 URLify:
	backward的思想

	1.4 Palindrome Permutation
	KEY IDEA: 下面根据此条准则：*至多只能出现一个奇数*
	原因：当字母数为偶数，那么显然全偶才可以，0个奇数
		 当字母数为奇数，则只能出现一个奇数。
		 又因为，当只有一个奇数的时候 => 字母数必为奇数
		 当0个奇数的时候 => 字母数必为偶数

	1) hash table, 新建一个数组存储，判断是否至多出现一个奇数（用一个boolean开关）
	2) 动态计算， 同步保存奇数的个数，即：一旦出现一个奇数，countOdd++,一旦出现一个偶数，countOdd--
	3) *3.1 涉及到奇偶的，一定要考虑到异或运算^!
		3.2 判断是否exactly含有一个1:
			00010000 - 1 = 00001111
			00010000 & 00001111 = 0
			所以对于一个checker而言，只需判断:
			`if ((checker - 1) & checker) == 0;`
		3.3 注意corner case， 比如没有输入任何字母的情况


	1.5 One Way
	感觉其实是很简单的一道题，只是性质没有想清楚。切记！一定要先想好思路，再开始写code！！【思考】

	1.6 String Compression
	相对来说也比较简答，但是代码还不够简洁，有很多控制条件可以在for循环里做到。【优化+思考】

	1.7 Rotate Matrix
	之前做过，这次思路不一样又做了一遍

	1.8 Zero Matrix
	解法1: 设置两个boolean数组，分别记录行和列，如果某一个数为0，那么该行、该列的数全部设置为0，并且以后考虑的时候直接跳过它。占用额外的空间是O(M+N)。
	
	1.9 String Rotation
	解法1：判断一个string是否是另一个string的rotation, s1 = ab, s2 = ba
	-> s1s1 = abab, s1s1永远包含了ba, 另外要保证长度相等，则可以判断。

	解法2：考虑到ab和ba的特性，对于string s1，从头开始在string s2上找对应的a片段，如果到了string2的结尾并且片段长度大于1，则认为已经找到。然后就是比较剩下的substring是否是相等的就可以了。
	每次判断时，如果相同，简单，两者都+1。如果不同，问题来了，还要判断s2[i]是否和s1[0]相同，如果相同，那么把s1的指针折返回0；如果不同，那么依旧把s1的指针折返为0，但是此时需要把s2的指针+1，来继续前进，否则就会陷入无法前进的死循环里。














