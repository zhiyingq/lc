2018年08月02日16:56:04:
	1.1 isUniqe
	1） set法 ✔
	2) 128位ASCII码数组法 (未想到)
	3) lowercase位运算法	(未想到)
	ASCII和set的思路很好理解
	关于使用位运算，因为字符串都是由lowercase组成的，a-z即0-25，是小于32位的，因此，1可以表示成Ox0001,一旦出现一个字符，比如'c'，我们可以把'c'-'a'保存起来，作为1左移的距离。在这里就是左移两位，同时我们有一个计数器为counter，初始值为0，这样当前26个bit中某一个和左移后的1进行与运算大于0的时候，就知道是重复了。

	1.2 Check Permutation
	1) ASCII: 建立对应的char[128]数组，存放并判断是否相等
	可以采用“减去法”，即先完成一个数组，然后从里面减去相应的元素判断是否为0，这样可以大大节省时间和空间复杂度
	2) HashMap法+减去法：适用于所有Unicode字符
	3) 排序+判断两个数组是否相等
	排序是非常有用的算法，但是时间复杂度比较高。Arrays.equals(a, b)

	1.3 URLify:
	backward的思想

	1.4 Palindrome Permutation
	KEY IDEA: 下面根据此条准则：*至多只能出现一个奇数*
	原因：当字母数为偶数，那么显然全偶才可以，0个奇数
		 当字母数为奇数，则只能出现一个奇数。
		 又因为，当只有一个奇数的时候 => 字母数必为奇数
		 当0个奇数的时候 => 字母数必为偶数

	1) hash table, 新建一个数组存储，判断是否至多出现一个奇数（用一个boolean开关）
	2) 动态计算， 同步保存奇数的个数，即：一旦出现一个奇数，countOdd++,一旦出现一个偶数，countOdd--
	3) *3.1 涉及到奇偶的，一定要考虑到异或运算^!
		3.2 判断是否exactly含有一个1:
			00010000 - 1 = 00001111
			00010000 & 00001111 = 0
			所以对于一个checker而言，只需判断:
			`if ((checker - 1) & checker) == 0;`
		3.3 注意corner case， 比如没有输入任何字母的情况















